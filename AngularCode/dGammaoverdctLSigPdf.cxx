/*****************************************************************************
* Project: RooFit                                                           *
*                                                                           *
* This code was autogenerated by RooClassFactory                            *
*****************************************************************************/
 // Your description goes here...
// q2 bin for P'4
   // Efficacite en cosThetaL : Legendre polynomial of order 4 DEFINED BETWEEN -.8 AND .8 (parameters are transformed in normal polynomials to simplify the integrals)
   // Efficacite en cosThetaK : Legendre polynomial of order 4 defined between -1 and 1 (parameters are transformed in normal polynomials to simplify the integrals)
   // efficacite en phi : 1 + cc*cos(2phi) + cs*Sin(2Phi)
 #include "Riostream.h"
 #include "dGammaoverdctLSigPdf.h"
 #include "RooAbsReal.h"
 #include "RooAbsCategory.h"
 #include <math.h>
 #include "TMath.h"
 ClassImp(dGammaoverdctLSigPdf)
 dGammaoverdctLSigPdf::dGammaoverdctLSigPdf(const char *name, const char *title,
                        RooAbsReal& _ctL,
                        RooAbsReal& _bCoeff,
                        RooAbsReal& _cCoeff,
                        RooAbsReal& _l1L,
                        RooAbsReal& _l2L,
		                    RooAbsReal& _l4L)  :
 RooAbsPdf(name,title),
   ctL("ctL","ctL",this,_ctL),
   bCoeff("bCoeff","bCoeff",this,_bCoeff),
   cCoeff("cCoeff","cCoeff",this,_cCoeff),
   l1L("l1L","l1L",this,_l1L),
   l2L("l2L","l2L",this,_l2L),
   l4L("l4L","l4L",this,_l4L)
 {
 }
 dGammaoverdctLSigPdf::dGammaoverdctLSigPdf(const dGammaoverdctLSigPdf& other, const char* name) :
   RooAbsPdf(other,name),
   ctL("ctL",this,other.ctL),
   bCoeff("bCoeff",this,other.bCoeff),
   cCoeff("cCoeff",this,other.cCoeff),
   l1L("l1L",this,other.l1L),
   l2L("l2L",this,other.l2L),
   l4L("l4L",this,other.l4L)
 {
 }
 Double_t dGammaoverdctLSigPdf::evaluate() const
 {
   // ENTER EXPRESSION IN TERMS OF VARIABLE ARGUMENTS HERE
   Double_t effctL = 1.;
   ///////////////////// CODE FOR EFFICIENCY WITH LEGENDRE ////////////////////////////
   // Efficacite en cosThetaL : Legendre polynomial of order 4  (parameters are transformed in normal polynomials to simplify the integrals)
   Double_t c0L, c1L, c2L, c4L;
   Double_t lNormL = (1. -0.5*l2L + 3./8.*l4L);
   c0L = 1.;
   c1L = l1L/lNormL;
   c2L = (l2L*3./2.-l4L*30./8.)/lNormL;
   c4L = (l4L*35./8.)/lNormL;

   //////////////////// NOW YOU HAVE NORMAL POLYNOMIALS ////////////////////////////////
   effctL = c0L + c1L*ctL + c2L*ctL*ctL + c4L*ctL*ctL*ctL*ctL ;

   Double_t theVal = 1 + bCoeff*ctL + cCoeff*ctL*ctL ;
   theVal = theVal*effctL ;
   return theVal ;
 }
Double_t dGammaoverdctLSigPdf::theValIntSin2XP4(Double_t x) const
{
  // Integrale de x^5*Sqrt(1-x^2)
  Double_t ans  = (-1./105.)*pow(1.-x*x,1.5)*(8.+12.*x*x+15.*x*x*x*x) ;
  return ans ;
}
Double_t dGammaoverdctLSigPdf::theValIntSin2XP3(Double_t x) const
{
  // Integrale de x^4*Sqrt(1-x^2)
  Double_t ans  = (1./48.)*(x*TMath::Sqrt(1.-x*x)*(-3.-2.*x*x+8.*x*x*x*x)+3.*TMath::ASin(x)) ;
  return ans ;
}
Double_t dGammaoverdctLSigPdf::theValIntSin2XP2(Double_t x) const
{
  // Integrale de x^3*Sqrt(1-x^2)
  Double_t ans  = (-1./15.)*pow(1.-x*x,1.5)*(2.+3.*x*x) ;
  return ans ;
}
Double_t dGammaoverdctLSigPdf::theValIntSin2XP1(Double_t x) const
{
  // Integrale de x^2*Sqrt(1-x^2)
  Double_t ans =  (1./8.)*(x*TMath::Sqrt(1.-x*x)*(-1.+2.*x*x) + TMath::ASin(x));
  return ans ;
}
Double_t dGammaoverdctLSigPdf::theValIntSin2XP0(Double_t x) const
{
  // Integrale de x*Sqrt(1-x^2)
  Double_t ans =  (-1./3.)*pow(1.-x*x,1.5) ;
  return ans ;
}

Int_t dGammaoverdctLSigPdf::getAnalyticalIntegral(RooArgSet& allVars, RooArgSet& analVars, const char* /*rangeName*/) const
{
  // LIST HERE OVER WHICH VARIABLES ANALYTICAL INTEGRATION IS SUPPORTED,
  // ASSIGN A NUMERIC CODE FOR EACH SUPPORTED (SET OF) PARAMETERS
  // THE EXAMPLE BELOW ASSIGNS CODE 1 TO INTEGRATION OVER VARIABLE X
  // YOU CAN ALSO IMPLEMENT MORE THAN ONE ANALYTICAL INTEGRAL BY REPEATING THE matchArgs
  // EXPRESSION MULTIPLE TIMES
  if (matchArgs(allVars,analVars,ctL)) return 1 ;
  return 0 ;
}
Double_t dGammaoverdctLSigPdf::analyticalIntegral(Int_t code, const char* rangeName) const
{
  // RETURN ANALYTICAL INTEGRAL DEFINED BY RETURN CODE ASSIGNED BY getAnalyticalIntegral
  // THE MEMBER FUNCTION x.min(rangeName) AND x.max(rangeName) WILL RETURN THE INTEGRATION
  // BOUNDARIES FOR EACH OBSERVABLE x
  ///////////////////// CODE FOR EFFICIENCY WITH LEGENDRE ////////////////////////////
  // Efficacite en cosThetaL : Legendre polynomial of order 4  (parameters are transformed in normal polynomials to simplify the integrals)
  // Efficacite en cosThetaK : Legendre polynomial of order 4 (parameters are transformed in normal polynomials to simplify the integrals)
  // efficacite en phi : 1 + cc*cos(2phi) + cs*Sin(2Phi)
  Double_t c0L, c1L, c2L, c4L;
  Double_t lNormL = (1. -0.5*l2L + 3./8.*l4L);
  c0L = 1.;
  c1L = l1L/lNormL;
  c2L = (l2L*3./2.-l4L*30./8.)/lNormL;
  c4L = (l4L*35./8.)/lNormL;

  //////////////////// NOW YOU HAVE NORMAL POLYNOMIALS ////////////////////////////////

//  Double_t effctL = c0L + c1L*ctL + c2L*ctL*ctL + c4L*ctL*ctL*ctL*ctL ;

  Double_t theVal ;

  Double_t Int_effctL ; //  int_{ctLMin,ctLMax} effctL
  Double_t Int_ctL2_effctL ; //  int_{ctLMin,ctLMax} ctL^2 * effctL
  Double_t Int_ctL_effctL ; //  int_{ctLMin,ctLMax} ctL * effctL

  Double_t ctLMin = ctL.min(rangeName) ;
  Double_t ctLMax = ctL.max(rangeName) ;


   //------------------------------------------------------------------------------
   // Now compute the integrals for ctL
   Double_t delta_ctL = ctLMax- ctLMin ;
   Double_t delta_ctL2 = 0. ;
   Double_t delta_ctL3 = pow(ctLMax,3)-pow(ctLMin,3) ;
   Double_t delta_ctL4 = 0. ;
   Double_t delta_ctL5 = pow(ctLMax,5)-pow(ctLMin,5) ;
   Double_t delta_ctL6 = 0. ;
   Double_t delta_ctL7 = pow(ctLMax,7)-pow(ctLMin,7) ;
   if (ctLMin != -ctLMax) {
     delta_ctL2 = pow(ctLMax,2)-pow(ctLMin,2) ;
     delta_ctL4 = pow(ctLMax,4)-pow(ctLMin,4) ;
     delta_ctL6 = pow(ctLMax,6)-pow(ctLMin,6) ;
   }

// to be coded more nicely with all the little intermediate functions ???

   Int_effctL = c0L*delta_ctL + (c1L/2.)*delta_ctL2 + (c2L/3.)*delta_ctL3 + (c4L/5.)*delta_ctL5 ;
   Int_ctL_effctL = (c0L/2.)*delta_ctL2 + (c1L/3.)*delta_ctL3 + (c2L/4.)*delta_ctL4 + (c4L/6.)*delta_ctL6 ;
   Int_ctL2_effctL = (c0L/3.)*delta_ctL3 + (c1L/4.)*delta_ctL4 + (c2L/5.)*delta_ctL5 + (c4L/7.)*delta_ctL7 ;

   // end of all the intermediate formulae !
   //---------------------------------------------------------------------------

   switch (code) {
   case 1 :
     // Integration over ctL
     theVal = Int_effctL + bCoeff*Int_ctL_effctL + cCoeff*Int_ctL2_effctL ;
     return theVal  ;
   default :
     return 0 ;
   }
 }
